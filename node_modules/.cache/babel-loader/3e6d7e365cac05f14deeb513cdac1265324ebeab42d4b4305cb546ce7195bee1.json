{"ast":null,"code":"// import React from \"react\";\n\nexport function SortAnimations(algoName, arr) {\n  const animations = [];\n  const tempArray = arr.slice();\n  const sortObj = {\n    animations: null,\n    sortedArray: null\n  };\n  switch (algoName) {\n    case \"Merge Sort\":\n      mergeSortAnimationsHelper(arr, 0, arr.length - 1, tempArray, animations);\n      return {\n        sortedArray: mergeSort(arr),\n        animations: animations\n      };\n    case \"Quick Sort\":\n      return {\n        sortedArray: quickSort(arr),\n        animations: null\n      };\n    case \"Heap Sort\":\n    case \"Bubble Sort\":\n    default:\n      sortObj.sortedArray = null;\n      sortObj.animations = null;\n  }\n  return sortObj;\n}\n\n// Merge Sort Functions\n_c = SortAnimations;\nconst merge = (leftArr, rightArr) => {\n  var result = [];\n  while (leftArr.length > 0 && rightArr.length > 0) result.push(leftArr[0] < rightArr[0] ? leftArr.shift() : rightArr.shift());\n  return result.concat(leftArr.length ? leftArr : rightArr);\n};\nfunction mergeSort(arr, animations) {\n  if (arr === null) {\n    return;\n  }\n  if (arr.length === 1) {\n    return arr;\n  }\n  const midIndex = Math.floor(arr.length / 2);\n  const leftArr = mergeSort(arr.slice(0, midIndex), animations);\n  const rightArr = mergeSort(arr.slice(midIndex), animations);\n  return merge(mergeSort(leftArr, animations), mergeSort(rightArr, animations));\n}\n\n// Merge Sort Animation Functions\nfunction mergeSortAnimationsHelper(arr, startIdx, endIdx, tempArray, animations) {\n  if (startIdx === endIdx) return;\n  const middleIdx = Math.floor((startIdx + endIdx) / 2);\n  mergeSortAnimationsHelper(tempArray, startIdx, middleIdx, arr, animations);\n  mergeSortAnimationsHelper(tempArray, middleIdx + 1, endIdx, arr, animations);\n  doMerge(arr, startIdx, middleIdx, endIdx, tempArray, animations);\n}\nfunction doMerge(arr, startIdx, middleIdx, endIdx, tempArray, animations) {\n  let k = startIdx;\n  let i = startIdx;\n  let j = middleIdx + 1;\n  while (i <= middleIdx && j <= endIdx) {\n    animations.push([i, j]);\n    animations.push([i, j]);\n    if (tempArray[i] <= tempArray[j]) {\n      animations.push([k, tempArray[i]]);\n      arr[k++] = tempArray[i++];\n    } else {\n      animations.push([k, tempArray[j]]);\n      arr[k++] = tempArray[j++];\n    }\n  }\n  while (i <= middleIdx) {\n    animations.push([i, i]);\n    animations.push([i, i]);\n    animations.push([k, tempArray[i]]);\n    arr[k++] = tempArray[i++];\n  }\n  while (j <= endIdx) {\n    animations.push([j, j]);\n    animations.push([j, j]);\n    animations.push([k, tempArray[j]]);\n    arr[k++] = tempArray[j++];\n  }\n}\n\n// Quick Sort Functions\nfunction quickSort(arr) {\n  // terminate execution and return array if empty\n  // or containing one elemrnt\n  if (arr.length <= 1) return arr;\n\n  // set the pivot to the last item on the list\n  const pivot = arr[arr.length - 1];\n\n  // create temporary contaners\n  const leftArr = [];\n  const rightArr = [];\n  const tempArr = arr.slice(0, arr.length - 1);\n\n  // loop through the array to put the pivot in its sorted position\n  for (let i = 0; i < tempArr.length; i++) {\n    if (tempArr[i] > pivot) {\n      rightArr.push(tempArr[i]);\n      animations.push([i, rightArr.findIndex(x => x === tempArr[i])]);\n    } else {\n      leftArr.push(tempArr[i]);\n    }\n  }\n\n  // repeat same processes above on both partition\n  // until every item is at its sorted position\n  return [...quickSort(leftArr), pivot, ...quickSort(rightArr)];\n}\nvar _c;\n$RefreshReg$(_c, \"SortAnimations\");","map":{"version":3,"names":["SortAnimations","algoName","arr","animations","tempArray","slice","sortObj","sortedArray","mergeSortAnimationsHelper","length","mergeSort","quickSort","_c","merge","leftArr","rightArr","result","push","shift","concat","midIndex","Math","floor","startIdx","endIdx","middleIdx","doMerge","k","i","j","pivot","tempArr","findIndex","x","$RefreshReg$"],"sources":["/Users/allisonchu/Projects/sorting-visualizer/src/utils/SortingAlgorithms.js"],"sourcesContent":["// import React from \"react\";\n\nexport function SortAnimations(algoName, arr) {\n  const animations = [];\n  const tempArray = arr.slice();\n  const sortObj = {\n    animations: null,\n    sortedArray: null,\n  };\n\n  switch (algoName) {\n    case \"Merge Sort\":\n      mergeSortAnimationsHelper(arr, 0, arr.length - 1, tempArray, animations);\n      return { sortedArray: mergeSort(arr), animations: animations };\n    case \"Quick Sort\":\n      return { sortedArray: quickSort(arr), animations: null };\n    case \"Heap Sort\":\n    case \"Bubble Sort\":\n    default:\n      sortObj.sortedArray = null;\n      sortObj.animations = null;\n  }\n\n  return sortObj;\n}\n\n// Merge Sort Functions\nconst merge = (leftArr, rightArr) => {\n  var result = [];\n\n  while (leftArr.length > 0 && rightArr.length > 0)\n    result.push(leftArr[0] < rightArr[0] ? leftArr.shift() : rightArr.shift());\n\n  return result.concat(leftArr.length ? leftArr : rightArr);\n};\n\nfunction mergeSort(arr, animations) {\n  if (arr === null) {\n    return;\n  }\n\n  if (arr.length === 1) {\n    return arr;\n  }\n\n  const midIndex = Math.floor(arr.length / 2);\n  const leftArr = mergeSort(arr.slice(0, midIndex), animations);\n  const rightArr = mergeSort(arr.slice(midIndex), animations);\n\n  return merge(mergeSort(leftArr, animations), mergeSort(rightArr, animations));\n}\n\n// Merge Sort Animation Functions\nfunction mergeSortAnimationsHelper(\n  arr,\n  startIdx,\n  endIdx,\n  tempArray,\n  animations\n) {\n  if (startIdx === endIdx) return;\n  const middleIdx = Math.floor((startIdx + endIdx) / 2);\n  mergeSortAnimationsHelper(tempArray, startIdx, middleIdx, arr, animations);\n  mergeSortAnimationsHelper(tempArray, middleIdx + 1, endIdx, arr, animations);\n  doMerge(arr, startIdx, middleIdx, endIdx, tempArray, animations);\n}\n\nfunction doMerge(arr, startIdx, middleIdx, endIdx, tempArray, animations) {\n  let k = startIdx;\n  let i = startIdx;\n  let j = middleIdx + 1;\n  while (i <= middleIdx && j <= endIdx) {\n    animations.push([i, j]);\n    animations.push([i, j]);\n    if (tempArray[i] <= tempArray[j]) {\n      animations.push([k, tempArray[i]]);\n      arr[k++] = tempArray[i++];\n    } else {\n      animations.push([k, tempArray[j]]);\n      arr[k++] = tempArray[j++];\n    }\n  }\n  while (i <= middleIdx) {\n    animations.push([i, i]);\n    animations.push([i, i]);\n    animations.push([k, tempArray[i]]);\n    arr[k++] = tempArray[i++];\n  }\n  while (j <= endIdx) {\n    animations.push([j, j]);\n    animations.push([j, j]);\n    animations.push([k, tempArray[j]]);\n    arr[k++] = tempArray[j++];\n  }\n}\n\n// Quick Sort Functions\nfunction quickSort(arr) {\n  // terminate execution and return array if empty\n  // or containing one elemrnt\n  if (arr.length <= 1) return arr;\n\n  // set the pivot to the last item on the list\n  const pivot = arr[arr.length - 1];\n\n  // create temporary contaners\n  const leftArr = [];\n  const rightArr = [];\n\n  const tempArr = arr.slice(0, arr.length - 1);\n\n  // loop through the array to put the pivot in its sorted position\n  for (let i = 0; i < tempArr.length; i++) {\n    if (tempArr[i] > pivot) {\n      rightArr.push(tempArr[i]);\n      animations.push([i, rightArr.findIndex((x) => x === tempArr[i])]);\n    } else {\n      leftArr.push(tempArr[i]);\n    }\n  }\n\n  // repeat same processes above on both partition\n  // until every item is at its sorted position\n  return [...quickSort(leftArr), pivot, ...quickSort(rightArr)];\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}