{"ast":null,"code":"// import React from \"react\";\n\nexport function SortAnimations(algoName, arr) {\n  const animations = [];\n  const tempArray = arr.slice();\n  const sortObj = {\n    animations: null,\n    sortedArray: null\n  };\n  switch (algoName) {\n    case \"Merge Sort\":\n      mergeSortAnimationsHelper(arr, 0, arr.length - 1, tempArray, animations);\n      return {\n        sortedArray: mergeSort(arr),\n        animations: animations\n      };\n    case \"Quick Sort\":\n    case \"Heap Sort\":\n    case \"Bubble Sort\":\n    default:\n      sortObj.sortedArray = null;\n      sortObj.animations = null;\n  }\n  return sortObj;\n}\n\n// Merge Sort Functions\n_c = SortAnimations;\nconst merge = (leftArr, rightArr) => {\n  var result = [];\n  while (leftArr.length > 0 && rightArr.length > 0) result.push(leftArr[0] < rightArr[0] ? leftArr.shift() : rightArr.shift());\n  return result.concat(leftArr.length ? leftArr : rightArr);\n};\nfunction mergeSort(arr, animations) {\n  if (arr === null) {\n    return;\n  }\n  if (arr.length === 1) {\n    return arr;\n  }\n  const midIndex = Math.floor(arr.length / 2);\n  const leftArr = mergeSort(arr.slice(0, midIndex), animations);\n  const rightArr = mergeSort(arr.slice(midIndex), animations);\n  return merge(mergeSort(leftArr, animations), mergeSort(rightArr, animations));\n}\n\n// Merge Sort Animation Functions\nfunction mergeSortAnimationsHelper(arr, startIdx, endIdx, tempArray, animations) {\n  if (startIdx === endIdx) return;\n  const middleIdx = Math.floor((startIdx + endIdx) / 2);\n  mergeSortAnimationsHelper(tempArray, startIdx, middleIdx, arr, animations);\n  mergeSortAnimationsHelper(tempArray, middleIdx + 1, endIdx, arr, animations);\n  doMerge(arr, startIdx, middleIdx, endIdx, tempArray, animations);\n}\nfunction doMerge(arr, startIdx, middleIdx, endIdx, tempArray, animations) {\n  let k = startIdx;\n  let i = startIdx;\n  let j = middleIdx + 1;\n  while (i <= middleIdx && j <= endIdx) {\n    animations.push([i, j]);\n    animations.push([i, j]);\n    if (tempArray[i] <= tempArray[j]) {\n      animations.push([k, tempArray[i]]);\n      arr[k++] = tempArray[i++];\n    } else {\n      animations.push([k, tempArray[j]]);\n      arr[k++] = tempArray[j++];\n    }\n  }\n  while (i <= middleIdx) {\n    animations.push([i, i]);\n    animations.push([i, i]);\n    animations.push([k, tempArray[i]]);\n    arr[k++] = tempArray[i++];\n  }\n  while (j <= endIdx) {\n    animations.push([j, j]);\n    animations.push([j, j]);\n    animations.push([k, tempArray[j]]);\n    arr[k++] = tempArray[j++];\n  }\n}\n\n// Quick Sort Functions\nfunction quickSort(arr, animations) {\n  // terminate execution and return array if empty\n  // or containing one elemrnt\n  if (arr.length <= 1) return arr;\n\n  // set the pivot to the last item on the list\n  const pivot = arr[arr.length - 1];\n\n  // create temporary contaners\n  const leftArr = [];\n  const rightArr = [];\n  const tempArr = arr.slice(0, arr.length - 1);\n\n  // loop through the array to put the pivot in its sorted position\n  for (let i = 0; i < tempArr.length; i++) {\n    animations.push([i, i]);\n    if (tempArr[i] > pivot) {\n      rightArr.push(tempArr[i]);\n      animations.push([i, rightArr.findIndex(x => x === tempArr[i])]);\n    } else {\n      leftArr.push(tempArr[i]);\n      animations.push([i, leftArr.findIndex(x => x === tempArr[i])]);\n    }\n  }\n\n  // repeat same processes above on both partition\n  // until every item is at its sorted position\n  return [...quickSort(leftArr, animations), pivot, ...quickSort(rightArr, animations)];\n}\nvar _c;\n$RefreshReg$(_c, \"SortAnimations\");","map":{"version":3,"names":["SortAnimations","algoName","arr","animations","tempArray","slice","sortObj","sortedArray","mergeSortAnimationsHelper","length","mergeSort","_c","merge","leftArr","rightArr","result","push","shift","concat","midIndex","Math","floor","startIdx","endIdx","middleIdx","doMerge","k","i","j","quickSort","pivot","tempArr","findIndex","x","$RefreshReg$"],"sources":["/Users/allisonchu/Projects/sorting-visualizer/src/utils/SortingAlgorithms.js"],"sourcesContent":["// import React from \"react\";\n\nexport function SortAnimations(algoName, arr) {\n  const animations = [];\n  const tempArray = arr.slice();\n  const sortObj = {\n    animations: null,\n    sortedArray: null,\n  };\n\n  switch (algoName) {\n    case \"Merge Sort\":\n      mergeSortAnimationsHelper(arr, 0, arr.length - 1, tempArray, animations);\n      return { sortedArray: mergeSort(arr), animations: animations };\n    case \"Quick Sort\":\n    case \"Heap Sort\":\n    case \"Bubble Sort\":\n    default:\n      sortObj.sortedArray = null;\n      sortObj.animations = null;\n  }\n\n  return sortObj;\n}\n\n// Merge Sort Functions\nconst merge = (leftArr, rightArr) => {\n  var result = [];\n\n  while (leftArr.length > 0 && rightArr.length > 0)\n    result.push(leftArr[0] < rightArr[0] ? leftArr.shift() : rightArr.shift());\n\n  return result.concat(leftArr.length ? leftArr : rightArr);\n};\n\nfunction mergeSort(arr, animations) {\n  if (arr === null) {\n    return;\n  }\n\n  if (arr.length === 1) {\n    return arr;\n  }\n\n  const midIndex = Math.floor(arr.length / 2);\n  const leftArr = mergeSort(arr.slice(0, midIndex), animations);\n  const rightArr = mergeSort(arr.slice(midIndex), animations);\n\n  return merge(mergeSort(leftArr, animations), mergeSort(rightArr, animations));\n}\n\n// Merge Sort Animation Functions\nfunction mergeSortAnimationsHelper(\n  arr,\n  startIdx,\n  endIdx,\n  tempArray,\n  animations\n) {\n  if (startIdx === endIdx) return;\n  const middleIdx = Math.floor((startIdx + endIdx) / 2);\n  mergeSortAnimationsHelper(tempArray, startIdx, middleIdx, arr, animations);\n  mergeSortAnimationsHelper(tempArray, middleIdx + 1, endIdx, arr, animations);\n  doMerge(arr, startIdx, middleIdx, endIdx, tempArray, animations);\n}\n\nfunction doMerge(arr, startIdx, middleIdx, endIdx, tempArray, animations) {\n  let k = startIdx;\n  let i = startIdx;\n  let j = middleIdx + 1;\n  while (i <= middleIdx && j <= endIdx) {\n    animations.push([i, j]);\n    animations.push([i, j]);\n    if (tempArray[i] <= tempArray[j]) {\n      animations.push([k, tempArray[i]]);\n      arr[k++] = tempArray[i++];\n    } else {\n      animations.push([k, tempArray[j]]);\n      arr[k++] = tempArray[j++];\n    }\n  }\n  while (i <= middleIdx) {\n    animations.push([i, i]);\n    animations.push([i, i]);\n    animations.push([k, tempArray[i]]);\n    arr[k++] = tempArray[i++];\n  }\n  while (j <= endIdx) {\n    animations.push([j, j]);\n    animations.push([j, j]);\n    animations.push([k, tempArray[j]]);\n    arr[k++] = tempArray[j++];\n  }\n}\n\n// Quick Sort Functions\nfunction quickSort(arr, animations) {\n  // terminate execution and return array if empty\n  // or containing one elemrnt\n  if (arr.length <= 1) return arr;\n\n  // set the pivot to the last item on the list\n  const pivot = arr[arr.length - 1];\n\n  // create temporary contaners\n  const leftArr = [];\n  const rightArr = [];\n\n  const tempArr = arr.slice(0, arr.length - 1);\n\n  // loop through the array to put the pivot in its sorted position\n  for (let i = 0; i < tempArr.length; i++) {\n    animations.push([i, i]);\n    if (tempArr[i] > pivot) {\n      rightArr.push(tempArr[i]);\n      animations.push([i, rightArr.findIndex((x) => x === tempArr[i])]);\n    } else {\n      leftArr.push(tempArr[i]);\n      animations.push([i, leftArr.findIndex((x) => x === tempArr[i])]);\n    }\n  }\n\n  // repeat same processes above on both partition\n  // until every item is at its sorted position\n  return [\n    ...quickSort(leftArr, animations),\n    pivot,\n    ...quickSort(rightArr, animations),\n  ];\n}\n"],"mappings":"AAAA;;AAEA,OAAO,SAASA,cAAcA,CAACC,QAAQ,EAAEC,GAAG,EAAE;EAC5C,MAAMC,UAAU,GAAG,EAAE;EACrB,MAAMC,SAAS,GAAGF,GAAG,CAACG,KAAK,CAAC,CAAC;EAC7B,MAAMC,OAAO,GAAG;IACdH,UAAU,EAAE,IAAI;IAChBI,WAAW,EAAE;EACf,CAAC;EAED,QAAQN,QAAQ;IACd,KAAK,YAAY;MACfO,yBAAyB,CAACN,GAAG,EAAE,CAAC,EAAEA,GAAG,CAACO,MAAM,GAAG,CAAC,EAAEL,SAAS,EAAED,UAAU,CAAC;MACxE,OAAO;QAAEI,WAAW,EAAEG,SAAS,CAACR,GAAG,CAAC;QAAEC,UAAU,EAAEA;MAAW,CAAC;IAChE,KAAK,YAAY;IACjB,KAAK,WAAW;IAChB,KAAK,aAAa;IAClB;MACEG,OAAO,CAACC,WAAW,GAAG,IAAI;MAC1BD,OAAO,CAACH,UAAU,GAAG,IAAI;EAC7B;EAEA,OAAOG,OAAO;AAChB;;AAEA;AAAAK,EAAA,GAvBgBX,cAAc;AAwB9B,MAAMY,KAAK,GAAGA,CAACC,OAAO,EAAEC,QAAQ,KAAK;EACnC,IAAIC,MAAM,GAAG,EAAE;EAEf,OAAOF,OAAO,CAACJ,MAAM,GAAG,CAAC,IAAIK,QAAQ,CAACL,MAAM,GAAG,CAAC,EAC9CM,MAAM,CAACC,IAAI,CAACH,OAAO,CAAC,CAAC,CAAC,GAAGC,QAAQ,CAAC,CAAC,CAAC,GAAGD,OAAO,CAACI,KAAK,CAAC,CAAC,GAAGH,QAAQ,CAACG,KAAK,CAAC,CAAC,CAAC;EAE5E,OAAOF,MAAM,CAACG,MAAM,CAACL,OAAO,CAACJ,MAAM,GAAGI,OAAO,GAAGC,QAAQ,CAAC;AAC3D,CAAC;AAED,SAASJ,SAASA,CAACR,GAAG,EAAEC,UAAU,EAAE;EAClC,IAAID,GAAG,KAAK,IAAI,EAAE;IAChB;EACF;EAEA,IAAIA,GAAG,CAACO,MAAM,KAAK,CAAC,EAAE;IACpB,OAAOP,GAAG;EACZ;EAEA,MAAMiB,QAAQ,GAAGC,IAAI,CAACC,KAAK,CAACnB,GAAG,CAACO,MAAM,GAAG,CAAC,CAAC;EAC3C,MAAMI,OAAO,GAAGH,SAAS,CAACR,GAAG,CAACG,KAAK,CAAC,CAAC,EAAEc,QAAQ,CAAC,EAAEhB,UAAU,CAAC;EAC7D,MAAMW,QAAQ,GAAGJ,SAAS,CAACR,GAAG,CAACG,KAAK,CAACc,QAAQ,CAAC,EAAEhB,UAAU,CAAC;EAE3D,OAAOS,KAAK,CAACF,SAAS,CAACG,OAAO,EAAEV,UAAU,CAAC,EAAEO,SAAS,CAACI,QAAQ,EAAEX,UAAU,CAAC,CAAC;AAC/E;;AAEA;AACA,SAASK,yBAAyBA,CAChCN,GAAG,EACHoB,QAAQ,EACRC,MAAM,EACNnB,SAAS,EACTD,UAAU,EACV;EACA,IAAImB,QAAQ,KAAKC,MAAM,EAAE;EACzB,MAAMC,SAAS,GAAGJ,IAAI,CAACC,KAAK,CAAC,CAACC,QAAQ,GAAGC,MAAM,IAAI,CAAC,CAAC;EACrDf,yBAAyB,CAACJ,SAAS,EAAEkB,QAAQ,EAAEE,SAAS,EAAEtB,GAAG,EAAEC,UAAU,CAAC;EAC1EK,yBAAyB,CAACJ,SAAS,EAAEoB,SAAS,GAAG,CAAC,EAAED,MAAM,EAAErB,GAAG,EAAEC,UAAU,CAAC;EAC5EsB,OAAO,CAACvB,GAAG,EAAEoB,QAAQ,EAAEE,SAAS,EAAED,MAAM,EAAEnB,SAAS,EAAED,UAAU,CAAC;AAClE;AAEA,SAASsB,OAAOA,CAACvB,GAAG,EAAEoB,QAAQ,EAAEE,SAAS,EAAED,MAAM,EAAEnB,SAAS,EAAED,UAAU,EAAE;EACxE,IAAIuB,CAAC,GAAGJ,QAAQ;EAChB,IAAIK,CAAC,GAAGL,QAAQ;EAChB,IAAIM,CAAC,GAAGJ,SAAS,GAAG,CAAC;EACrB,OAAOG,CAAC,IAAIH,SAAS,IAAII,CAAC,IAAIL,MAAM,EAAE;IACpCpB,UAAU,CAACa,IAAI,CAAC,CAACW,CAAC,EAAEC,CAAC,CAAC,CAAC;IACvBzB,UAAU,CAACa,IAAI,CAAC,CAACW,CAAC,EAAEC,CAAC,CAAC,CAAC;IACvB,IAAIxB,SAAS,CAACuB,CAAC,CAAC,IAAIvB,SAAS,CAACwB,CAAC,CAAC,EAAE;MAChCzB,UAAU,CAACa,IAAI,CAAC,CAACU,CAAC,EAAEtB,SAAS,CAACuB,CAAC,CAAC,CAAC,CAAC;MAClCzB,GAAG,CAACwB,CAAC,EAAE,CAAC,GAAGtB,SAAS,CAACuB,CAAC,EAAE,CAAC;IAC3B,CAAC,MAAM;MACLxB,UAAU,CAACa,IAAI,CAAC,CAACU,CAAC,EAAEtB,SAAS,CAACwB,CAAC,CAAC,CAAC,CAAC;MAClC1B,GAAG,CAACwB,CAAC,EAAE,CAAC,GAAGtB,SAAS,CAACwB,CAAC,EAAE,CAAC;IAC3B;EACF;EACA,OAAOD,CAAC,IAAIH,SAAS,EAAE;IACrBrB,UAAU,CAACa,IAAI,CAAC,CAACW,CAAC,EAAEA,CAAC,CAAC,CAAC;IACvBxB,UAAU,CAACa,IAAI,CAAC,CAACW,CAAC,EAAEA,CAAC,CAAC,CAAC;IACvBxB,UAAU,CAACa,IAAI,CAAC,CAACU,CAAC,EAAEtB,SAAS,CAACuB,CAAC,CAAC,CAAC,CAAC;IAClCzB,GAAG,CAACwB,CAAC,EAAE,CAAC,GAAGtB,SAAS,CAACuB,CAAC,EAAE,CAAC;EAC3B;EACA,OAAOC,CAAC,IAAIL,MAAM,EAAE;IAClBpB,UAAU,CAACa,IAAI,CAAC,CAACY,CAAC,EAAEA,CAAC,CAAC,CAAC;IACvBzB,UAAU,CAACa,IAAI,CAAC,CAACY,CAAC,EAAEA,CAAC,CAAC,CAAC;IACvBzB,UAAU,CAACa,IAAI,CAAC,CAACU,CAAC,EAAEtB,SAAS,CAACwB,CAAC,CAAC,CAAC,CAAC;IAClC1B,GAAG,CAACwB,CAAC,EAAE,CAAC,GAAGtB,SAAS,CAACwB,CAAC,EAAE,CAAC;EAC3B;AACF;;AAEA;AACA,SAASC,SAASA,CAAC3B,GAAG,EAAEC,UAAU,EAAE;EAClC;EACA;EACA,IAAID,GAAG,CAACO,MAAM,IAAI,CAAC,EAAE,OAAOP,GAAG;;EAE/B;EACA,MAAM4B,KAAK,GAAG5B,GAAG,CAACA,GAAG,CAACO,MAAM,GAAG,CAAC,CAAC;;EAEjC;EACA,MAAMI,OAAO,GAAG,EAAE;EAClB,MAAMC,QAAQ,GAAG,EAAE;EAEnB,MAAMiB,OAAO,GAAG7B,GAAG,CAACG,KAAK,CAAC,CAAC,EAAEH,GAAG,CAACO,MAAM,GAAG,CAAC,CAAC;;EAE5C;EACA,KAAK,IAAIkB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGI,OAAO,CAACtB,MAAM,EAAEkB,CAAC,EAAE,EAAE;IACvCxB,UAAU,CAACa,IAAI,CAAC,CAACW,CAAC,EAAEA,CAAC,CAAC,CAAC;IACvB,IAAII,OAAO,CAACJ,CAAC,CAAC,GAAGG,KAAK,EAAE;MACtBhB,QAAQ,CAACE,IAAI,CAACe,OAAO,CAACJ,CAAC,CAAC,CAAC;MACzBxB,UAAU,CAACa,IAAI,CAAC,CAACW,CAAC,EAAEb,QAAQ,CAACkB,SAAS,CAAEC,CAAC,IAAKA,CAAC,KAAKF,OAAO,CAACJ,CAAC,CAAC,CAAC,CAAC,CAAC;IACnE,CAAC,MAAM;MACLd,OAAO,CAACG,IAAI,CAACe,OAAO,CAACJ,CAAC,CAAC,CAAC;MACxBxB,UAAU,CAACa,IAAI,CAAC,CAACW,CAAC,EAAEd,OAAO,CAACmB,SAAS,CAAEC,CAAC,IAAKA,CAAC,KAAKF,OAAO,CAACJ,CAAC,CAAC,CAAC,CAAC,CAAC;IAClE;EACF;;EAEA;EACA;EACA,OAAO,CACL,GAAGE,SAAS,CAAChB,OAAO,EAAEV,UAAU,CAAC,EACjC2B,KAAK,EACL,GAAGD,SAAS,CAACf,QAAQ,EAAEX,UAAU,CAAC,CACnC;AACH;AAAC,IAAAQ,EAAA;AAAAuB,YAAA,CAAAvB,EAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}